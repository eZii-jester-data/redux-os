const character3dAssetId = <%= 13 %>;
const brick3dAssetId = <%= 12 %>;




import EZIIBrickLayerGameMain from './eZii-bricklayer-game/main.js';
import * as THREE from 'three';



$(function() {
	
	
	var main = new EZIIBrickLayerGameMain();
	
	var playerWalkingDirection = [0, 0, 0];
	main.findDomDockingPoint().then(function() {
		main.init();
		main.moveObjectZAxis(main.cubes[1]);
		
        
        const geometry = new THREE.BoxGeometry( 1, 1, 1 );
const material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
const cube = new THREE.Mesh( geometry, material );
main.scene.add( cube );



		window.threeJsScene = main.scene;
		
		

        
	
		main.addObject(character3dAssetId).then(function([object, mixer, id]) {
			window.mainObject = object;
			main.mixers[id] = mixer;
		
			main.animate(id);
		
            window.mainObject.position.z = 20;
            window.mainObject.scale.set(0.1, 0.1, 0.1);
			
			
			main.every10MilliSeconds(function() {
				window.mainObject.position.z += playerWalkingDirection[2] / 5;
				window.mainObject.position.y += playerWalkingDirection[1] / 5;
				window.mainObject.position.x += playerWalkingDirection[0] / 5;
			})
			
			main.every10MilliSeconds(function() {
				if (window.positionWanted === undefined) return;
				
				if ((window.mainObject.position.z < window.positionWanted.z + 0.10) && (window.mainObject.position	.z > window.positionWanted.z - 0.10) && (window.mainObject.position	.x < window.positionWanted.x + 0.10) && (window.mainObject.position	.x > window.positionWanted.x - 0.10)) {
					window.positionWanted = undefined;
					playerWalkingDirection = [0,0,0]
					
					main.stopAnimation(character3dAssetId);
					
					while(main.stoppedMixers[character3dAssetId] && main.stoppedMixers[character3dAssetId].time > 0.3) {
						main.stoppedMixers[character3dAssetId].update(-0.1);
					}		
				}
			})
			
			main.every10MilliSeconds(function() {
				if(main.stoppedMixers[character3dAssetId] !== undefined && main.stoppedMixers[character3dAssetId].time > 0.2) {
					main.stoppedMixers[character3dAssetId].update(-0.001);
				}
			})
		});
		
		
		main.addObject(brick3dAssetId).then(function([object, mixer, id]) {
			window.mainObject2 = object;
			
			main.mixers[id] = mixer;
		
			// main.animate(id);
		
            window.mainObject2.position.z = 20;
            
            window.mainObject2.visible = false;
		});
		
	
		
		
		main.grid.on('click', function(ev) {
			console.log(ev);
			
			main.startAnimation(character3dAssetId);
			
			let dir = new THREE.Vector3();
			
			let position = new THREE.Vector3(window.mainObject.position.x, 0, window.mainObject.position.z);
			let positionWanted = new THREE.Vector3(ev.intersects[0].point.x, 0, ev.intersects[0].point.z);
			window.positionWanted = positionWanted;
			dir.subVectors( positionWanted, position).normalize();
			
			playerWalkingDirection[0] = dir.x;
			playerWalkingDirection[2] = dir.z;
			
			window.lastUpdateForMainObjectLookAt = positionWanted;
			window.mainObject.lookAt(positionWanted);
		});

    });
});


